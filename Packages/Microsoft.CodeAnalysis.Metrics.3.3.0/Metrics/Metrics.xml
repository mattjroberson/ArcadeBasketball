<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metrics</name>
    </assembly>
    <members>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.Count``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns the number of elements in a sequence.
            </summary>
            <typeparam name="TSource">he type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <returns>The number of elements in the input sequence.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasExactly``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains, exactly, <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains, exactly, <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasMoreThan``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence containsmore than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains more than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:System.Collections.Immutable.ImmutableArrayExtensions.HasFewerThan``1(System.Collections.Immutable.ImmutableArray{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains fewer than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains less then <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1">
            <summary>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> that can be recycled via an object pool.
            </summary>
        </member>
        <member name="P:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a <paramref name="value"/> to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the given <paramref name="values"/> to the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Clear">
            <summary>
            Clears all the elements from the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.Contains(`0)">
            <summary>
            Returns true if the given <paramref name="item"/> is present in the set.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.PooledConcurrentDictionary`2">
            <summary>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> that can be recycled via an object pool.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.BoundedCacheWithFactory`2">
            <summary>
            Provides bounded cache for analyzers.
            Acts as a good alternative to <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/>
            when the cached value has a cyclic reference to the key preventing early garbage collection of entries.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Analyzer.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="T:Analyzer.Utilities.DoNotCatchGeneralUnlessRethrownAnalyzer.DisallowGeneralCatchUnlessRethrowWalker">
            <summary>
            Walks an IOperation tree to find catch blocks that handle general types without rethrowing them.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.CompilationExtensions">
            <summary>
            Provides extensions to <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.GetOrCreateTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String)">
            <summary>
            Gets a type by its full type name and cache it at the compilation level.
            </summary>
            <param name="compilation">The compilation.</param>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.TryGetOrCreateTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String,Microsoft.CodeAnalysis.INamedTypeSymbol@)">
            <summary>
            Gets a type by its full type name and cache it at the compilation level.
            </summary>
            <param name="compilation">The compilation.</param>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.CompilationExtensions.TargetsDotNetFramework(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets a value indicating, whether the compilation of assembly targets .NET Framework.
            This method differentiates between .NET Framework and other frameworks (.NET Core, .NET Standard, .NET 5 in future).
            </summary>
            <param name="compilation">The compilation</param>
            <returns><c>True</c> if the compilation targets .NET Framework; otherwise <c>false</c>.</returns>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1">
            <summary>
            This will only compile if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> have the
            same value.
            </summary>
            <remarks>
            <para>The subtraction in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1"/> will overflow if <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> is greater, and the conversion
            to an unsigned value after negation in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2"/> will overflow if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> is greater.</para>
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2">
            <summary>
            This will only compile if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> have the
            same value.
            </summary>
            <remarks>
            <para>The subtraction in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion1"/> will overflow if <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> is greater, and the conversion
            to an unsigned value after negation in <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunctionValueAssertion2"/> will overflow if <see cref="F:Analyzer.Utilities.Extensions.MethodKindEx.LocalFunction"/> is greater.</para>
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.DiagnosticExtensions.s_syntaxTreeDiagnosticOptionsProperty">
            <summary>
            TODO: Revert this reflection based workaround once we move to Microsoft.CodeAnalysis version 3.0
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasExactly``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains, exactly, <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains, exactly, <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasMoreThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains more than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains more than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableExtensions.HasFewerThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whether a sequence contains fewer than <paramref name="count"/> elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to check for cardinality.</param>
            <param name="count">The number of elements to ensure exists.</param>
            <returns><see langword="true" /> the source sequence contains less than <paramref name="count"/> elements; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.WhereMethodDoesNotContainAttribute(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Excludes <paramref name="methods"/> that have an attribute that precisely matches <paramref name="attributeType"/>.
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to filter.</param>
            <param name="attributeType">The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> of the attribute class to search.</param>
            <returns>A filtered list of methods.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean)">
            <summary>
            Returns a list of method symbols from a given list of the method symbols, which has its parameter type as
            expectedParameterType as its first parameter or the last parameter in addition to matching all the other 
            parameter types of the selectedOverload method symbol
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to scan for possible overloads</param>
            <param name="selectedOverload"><see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> that is currently picked by the user</param>
            <param name="expectedParameterType"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> type of the leading parameter or the trailing parameter</param>
            <param name="trailingOnly"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> If the expected parameter should appear at the trailing position of the parameter list of the method overload</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetMethodOverloadsWithDesiredParameterAtTrailing(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a list of method symbols from a given list of the method symbols, which has its parameter type as
            expectedParameterType as its last parameter in addition to matching all the other parameter types of the 
            selectedOverload method symbol
            </summary>
            <param name="methods">List of <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> to scan for possible overloads</param>
            <param name="selectedOverload"><see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/> that is currently picked by the user</param>
            <param name="expectedTrailingParameterType"><see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> type of the leading parameter or the trailing parameter</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions.GetFirstOrDefaultMemberWithParameterInfos(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Analyzer.Utilities.Extensions.ParameterInfo[])">
            <summary>
            Given a <see cref="T:System.Collections.Generic.IEnumerable`1"/>, this method returns the method symbol which 
            matches the expectedParameterTypesInOrder parameter requirement
            </summary>
            <param name="members"></param>
            <param name="expectedParameterTypesInOrder"></param>
            <returns></returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectEqualsOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectEquals(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method is <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsStaticObjectEqualsOrReferenceEquals(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given <paramref name="method"/> is <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsGetHashCodeOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides Object.GetHashCode.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsToStringOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides Object.ToString.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsObjectMethodOverride(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method overrides a method from System.Object
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsFinalizer(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method is a Finalizer implementation.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsImplementationOfInterfaceMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String)">
            <summary>
            Checks if the given method is an implementation of the given interface method
            Substituted with the given typeargument.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Checks if the given method implements IDisposable.Dispose()
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsDisposeImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements <see cref="M:System.IDisposable.Dispose"/> or overrides an implementation of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeSignatureByConvention(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method matches Dispose method convention and can be recognized by "using".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeBoolMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Dispose(bool)".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeCloseMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the given method has the signature "void Close()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeCloseAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "Task CloseAsync()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasDisposeAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "Task DisposeAsync()" or "ValueTask DisposeAsync()".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasOverriddenDisposeCoreAsyncMethodSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method has the signature "override Task DisposeCoreAsync(bool)".
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetDisposeMethodKind(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets the <see cref="T:Analyzer.Utilities.DisposeMethodKind"/> for the given method.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetDisposeMethodKind(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets the <see cref="T:Analyzer.Utilities.DisposeMethodKind"/> for the given method.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsOnDeserializationImplementation(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks if the given method implements 'System.Runtime.Serialization.IDeserializationCallback.OnDeserialization' or overrides an implementation of 'System.Runtime.Serialization.IDeserializationCallback.OnDeserialization'/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsPropertyGetter(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is a property getter.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsIndexerGetter(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is the getter for an indexer.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsPropertyAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an accessor for a property.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsEventAccessor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if the method is an accessor for an event.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_collectionAddMethodNameVariants">
            <summary>
            Set of well-known collection add method names.
            Used in <see cref="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsCollectionAddMethod(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.INamedTypeSymbol})"/> heuristic.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsCollectionAddMethod(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Determine if the specific method is an Add method that adds to a collection.
            </summary>
            <param name="method">The method to test.</param>
            <param name="iCollectionTypes">Collection types.</param>
            <returns>'true' if <paramref name="method"/> is believed to be the add method of a collection.</returns>
            <remarks>
            We use the following heuristic to determine if a method is a collection add method:
            1. Method's enclosing type implements any of the given <paramref name="iCollectionTypes"/>.
            2. Any of the following name heuristics are met:
                a. Method's name is from one of the well-known add method names from <see cref="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_collectionAddMethodNameVariants"/> ("Add", "AddOrUpdate", "GetOrAdd", "TryAdd", or "TryUpdate")
                b. Method's name begins with "Add" (FxCop compat)
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTaskFromResultMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determine if the specific method is a Task.FromResult method that wraps a result in a task.
            </summary>
            <param name="method">The method to test.</param>
            <param name="taskType">Task type.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsTaskConfigureAwaitMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determine if the specific method is a Task.ConfigureAwait(bool) method.
            </summary>
            <param name="method">The method to test.</param>
            <param name="genericTaskType">Generic task type.</param>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_methodToTopmostOperationBlockCache">
            <summary>
            PERF: Cache from method symbols to their topmost block operations to enable interprocedural flow analysis
            across analyzers and analyzer callbacks to re-use the operations, semanticModel and control flow graph.
            </summary>
            <remarks>Also see <see cref="F:Analyzer.Utilities.Extensions.IOperationExtensions.s_operationToCfgCache"/></remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.GetTopmostOperationBlock(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns the topmost <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> for given <paramref name="method"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.HasEventHandlerSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true for void returning methods with two parameters, where
            the first parameter is of <see cref="T:System.Object"/> type and the second
            parameter inherits from or equals <see cref="T:System.EventArgs"/> type or
            whose name ends with 'EventArgs'.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsOverrideOrVirtualMethodOf(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Find out if the method overrides from target virtual method of a certain type
            or it is the virtual method itself.
            </summary>
            <param name="methodSymbol">The method</param>
            <param name="typeSymbol">The type has virtual method</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.IsArgumentNullCheckMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns true if this is a bool returning static method whose name starts with "IsNull"
            with a single parameter whose type is not a value type.
            For example, "static bool string.IsNullOrEmpty()"
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.DerivesFromOrImplementsAnyConstructionOf(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether <paramref name="type"/> derives from, or implements
            any generic construction of, the type defined by <paramref name="parentType"/>.
            </summary>
            <remarks>
            This method only works when <paramref name="parentType"/> is a definition,
            not a constructed type.
            </remarks>
            <example>
            <para>
            If <paramref name="parentType"/> is the class <see cref="T:System.Collections.Generic.Stack`1"/>, then this
            method will return <see langword="true"/> when called on <c>Stack&gt;int></c>
            or any type derived it, because <c>Stack&gt;int></c> is constructed from
            <see cref="T:System.Collections.Generic.Stack`1"/>.
            </para>
            <para>
            Similarly, if <paramref name="parentType"/> is the interface <see cref="T:System.Collections.Generic.IList`1"/>, 
            then this method will return <see langword="true"/> for <c>List&gt;int></c>
            or any other class that extends <see cref="T:System.Collections.Generic.IList`1"/> or an class that implements it,
            because <c>IList&gt;int></c> is constructed from <see cref="T:System.Collections.Generic.IList`1"/>.
            </para>
            </example>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.ImplementsEqualityOperators(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified type implements both the
            equality and inequality operators.
            </summary>
            <param name="symbol">
            A symbols specifying the type to examine.
            </param>
            <returns>
            true if the type specified by <paramref name="symbol"/> implements both the
            equality and inequality operators, otherwise false.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsStaticHolderType(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified symbol is a static
            holder type.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> is a static holder type;
            otherwise <see langword="false"/>.
            </returns>
            <remarks>
            A symbol is a static holder type if it is a class with at least one
            "qualifying member" (<see cref="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsQualifyingMember(Microsoft.CodeAnalysis.ISymbol)"/>) and no
            "disqualifying members" (<see cref="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsDisqualifyingMember(Microsoft.CodeAnalysis.ISymbol)"/>).
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsQualifyingMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a value indicating whether the specified symbol qualifies as a
            member of a static holder class.
            </summary>
            <param name="member">
            The member being examined.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="member"/> qualifies as a member of
            a static holder class; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions.IsDisqualifyingMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a value indicating whether the presence of the specified symbol
            disqualifies a class from being considered a static holder class.
            </summary>
            <param name="member">
            The member being examined.
            </param>
            <returns>
            <see langword="true"/> if the presence of <paramref name="member"/> disqualifies the
            current type as a static holder class; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetReceiverType(Microsoft.CodeAnalysis.Operations.IInvocationOperation,Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the receiver type for an invocation expression (i.e. type of 'A' in invocation 'A.B()')
            If the invocation actually involves a conversion from A to some other type, say 'C', on which B is invoked,
            then this method returns type A if <paramref name="beforeConversion"/> is true, and C if false.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WithoutFullyImplicitOperations(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation})">
            <summary>
            Filters out operations that are implicit and have no explicit descendant with a constant value or a non-null type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetTopmostExplicitDescendants(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Gets explicit descendants or self of the given <paramref name="operation"/> that have no explicit ancestor in
            the operation tree rooted at <paramref name="operation"/>.
            </summary>
            <param name="operation">Operation</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsOperationNoneRoot(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            True if this operation has no IOperation API support, i.e. <see cref="F:Microsoft.CodeAnalysis.OperationKind.None"/> and
            is the root operation, i.e. <see cref="P:Microsoft.CodeAnalysis.Operation.Parent"/> is null.
            For example, this returns true for attribute operations.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetTopmostParentBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns the topmost <see cref="T:Microsoft.CodeAnalysis.Operations.IBlockOperation"/> containing the given <paramref name="operation"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetAncestor``1(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.OperationKind,System.Func{``0,System.Boolean})">
            <summary>
            Gets the first ancestor of this operation with:
             1. Specified OperationKind
             2. If <paramref name="predicateOpt"/> is non-null, it succeeds for the ancestor.
            Returns null if there is no such ancestor.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetInstance(Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation,System.Boolean)">
            <summary>
            Gets the operation for the object being created that is being referenced by <paramref name="operation"/>.
            If the operation is referencing an implicit or an explicit this/base/Me/MyBase/MyClass instance, then we return "null".
            </summary>
            <param name="operation"></param>
            <param name="isInsideAnonymousObjectInitializer">Flag to indicate if the operation is a descendant of an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation"/>.</param>
            <remarks>
            PERF: Note that the parameter <paramref name="isInsideAnonymousObjectInitializer"/> is to improve performance by avoiding walking the entire IOperation parent for non-initializer cases.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetAnonymousObjectCreation(Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation)">
            <summary>
            Workaround for https://github.com/dotnet/roslyn/issues/22736 (IPropertyReferenceExpressions in IAnonymousObjectCreationExpression are missing a receiver).
            Gets the instance for the anonymous object being created that is being referenced by <paramref name="operation"/>.
            Otherwise, returns null
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.IsComparisonOperator(Microsoft.CodeAnalysis.Operations.IBinaryOperation)">
            <summary>
            Indicates if the given <paramref name="binaryOperation"/> is a predicate operation used in a condition.
            </summary>
            <param name="binaryOperation"></param>
            <returns></returns>
        </member>
        <member name="F:Analyzer.Utilities.Extensions.IOperationExtensions.s_operationToCfgCache">
            <summary>
            PERF: Cache from operation roots to their corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/> to enable interprocedural flow analysis
            across analyzers and analyzer callbacks to re-use the control flow graph.
            </summary>
            <remarks>Also see <see cref="F:Analyzer.Utilities.Extensions.IMethodSymbolExtensions.s_methodToTopmostOperationBlockCache"/></remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.GetCaptures(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Gets the symbols captured from the enclosing function(s) by the given lambda or local function.
            </summary>
            <param name="operation">Operation representing the lambda or local function.</param>
            <param name="lambdaOrLocalFunction">Method symbol for the lambda or local function.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.TryGetParentTupleOperation(Microsoft.CodeAnalysis.Operations.ITupleOperation,Microsoft.CodeAnalysis.Operations.ITupleOperation@,Microsoft.CodeAnalysis.IOperation@)">
            <summary>
            If the given <paramref name="tupleOperation"/> is a nested tuple,
            gets the parenting tuple operation and the tuple element of that parenting tuple
            which contains the given tupleOperation as a descendant operation.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownParentheses(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consequtive parenthesized operations until an operand is reached that isn't a parenthesized operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non parenthesized operation or the starting operation if it wasn't a parenthesized operation.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.IOperationExtensions.WalkDownConversion(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consequtive conversion operations until an operand is reached that isn't a conversion operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non conversion operation or the starting operation if it wasn't a conversion operation.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.MatchesConfiguredVisibility(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,Analyzer.Utilities.SymbolVisibilityGroup)">
            <summary>
            Returns true if the given source symbol has required visibility based on options:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> in editor config options and
                 given symbol's visibility is one of the candidate visibilites.
              2. Otherwise, if user has not configured visibility, and given symbol's visibility
                 matches the given default symbol visibility.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.MatchesConfiguredVisibility(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,Analyzer.Utilities.SymbolVisibilityGroup)">
            <summary>
            Returns true if the given symbol has required visibility based on options in context of the given containing symbol:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> in editor config options and
                 given symbol's visibility is one of the candidate visibilites.
              2. Otherwise, if user has not configured visibility, and given symbol's visibility
                 matches the given default symbol visibility.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsConfiguredToSkipAnalysis(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns true if the given source symbol has been configured to be excluded from analysis by options.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsConfiguredToSkipAnalysis(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns true if the given symbol has been configured to be excluded from analysis by options in context of the given containing symbol.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.MatchesConfiguredModifiers(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken,Analyzer.Utilities.SymbolModifiers)">
            <summary>
            Returns true if the given symbol has required symbol modifiers based on options:
              1. If user has explicitly configured candidate <see cref="T:Analyzer.Utilities.SymbolModifiers"/> in editor config options and
                 given symbol has all the required modifiers.
              2. Otherwise, if user has not configured modifiers.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsExternallyVisible(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            True if the symbol is externally visible outside this assembly.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.FormatMemberName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Format member names in a way consistent with FxCop's display format.
            </summary>
            <param name="member"></param>
            <returns>
            A string representing the name of the member in a format consistent with FxCop.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ContainsParameterOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Check whether given parameters contains any parameter with given type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParametersOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Get parameters which type is the given type
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasOverloadWithParameterOfType(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Check whether given overloads has any overload whose parameters has the given type as its parameter type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetParameterIndices(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},System.Threading.CancellationToken)">
            <summary>
            Convert given parameters to the indices to the given method's parameter list.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ParametersAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check whether parameter count and parameter types of the given methods are same.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ParameterTypesAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Check whether parameter types of the given methods are same for given parameter indices.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.ReturnTypeAndParametersAreSame(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Check whether return type, parameters count and parameter types are same for the given methods.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsFromMscorlib(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Check whether given symbol is from mscorlib
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetMatchingOverload(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},System.Int32,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Get overload from the given overloads that matches given method signature + given parameter
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member implicitly or explicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyImplicitInterfaceMember``1(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member implicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsOverrideOrImplementationOfInterfaceMember(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member or overrides an implementation of an interface member.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.GetOverriddenMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the symbol overridden by the given <paramref name="symbol"/>.
            </summary>
            <remarks>Requires that <see cref="P:Microsoft.CodeAnalysis.ISymbol.IsOverride"/> is true for the given <paramref name="symbol"/>.</remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsImplementationOfAnyExplicitInterfaceMember(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Checks if a given symbol implements an interface member explicitly
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.HasAttribute(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns a value indicating whether the specified symbol has the specified
            attribute.
            </summary>
            <param name="symbol">
            The symbol being examined.
            </param>
            <param name="attribute">
            The attribute in question.
            </param>
            <returns>
            <see langword="true"/> if <paramref name="symbol"/> has an attribute of type
            <paramref name="attribute"/>; otherwise <see langword="false"/>.
            </returns>
            <remarks>
            If <paramref name="symbol"/> is a type, this method does not find attributes
            on its base types.
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsInSource(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Indicates if a symbol has at least one location in source.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ISymbolExtensions.IsSymbolWithSpecialDiscardName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true for symbols whose name starts with an underscore and
            are optionally followed by an integer, such as '_', '_1', '_2', etc.
            These symbols can be treated as special discard symbol names.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.IsDisposable(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Indicates if the given <paramref name="type"/> is disposable,
            and thus can be used in a <code>using</code> or <code>await using</code> statement.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.GetApplicableAttributes(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Gets all attributes directly applied to the type or inherited from a base type.
            </summary>
            <param name="type">The type symbol.</param>
            <param name="attributeUsageAttribute">The compilation symbol for <see cref="T:System.AttributeUsageAttribute"/>.</param>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.ITypeSymbolExtensions.HasAnyCollectionCountProperty(Microsoft.CodeAnalysis.ITypeSymbol,Analyzer.Utilities.WellKnownTypeProvider)">
            <summary>
            Checks whether the current type contains one of the following count property:
                - <see cref="P:System.Collections.ICollection.Count"/>
                - <see cref="P:System.Collections.Generic.ICollection`1.Count"/>
                - <see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
            </summary>
            <param name="invocationTarget">The type to check</param>
            <param name="wellKnownTypeProvider">An instance of the <see cref="T:Analyzer.Utilities.WellKnownTypeProvider"/> used to access the three described known types.</param>
            <returns><c>true</c> when the type contains one of the supported collection count property; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Analyzer.Utilities.Extensions.SymbolVisibilityExtensions">
            <summary>
            Extensions for <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Extensions.SymbolVisibilityExtensions.IsAtLeastAsVisibleAs(Analyzer.Utilities.Extensions.SymbolVisibility,Analyzer.Utilities.Extensions.SymbolVisibility)">
            <summary>
            Determines whether <paramref name="typeVisibility"/> is at least as visible as <paramref name="comparisonVisibility"/>.
            </summary>
            <param name="typeVisibility">The visibility to compare against.</param>
            <param name="comparisonVisibility">The visibility to compare with.</param>
            <returns>True if one can say that <paramref name="typeVisibility"/> is at least as visible as <paramref name="comparisonVisibility"/>.</returns>
            <remarks>
            For example, <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Public"/> is at least as visible as <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Internal"/>, but <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Private"/> is not as visible as <see cref="F:Analyzer.Utilities.Extensions.SymbolVisibility.Public"/>.
            </remarks>
        </member>
        <member name="T:Analyzer.Utilities.DisposeMethodKind">
            <summary>
            Describes different kinds of Dispose-like methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.None">
            <summary>
            Not a dispose-like method.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.Dispose">
            <summary>
            An override of <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeBool">
            <summary>
            A virtual method named Dispose that takes a single Boolean parameter, as
            is used when implementing the standard Dispose pattern.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeAsync">
            <summary>
            A method named DisposeAsync that has no parameters and returns Task.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.DisposeCoreAsync">
            <summary>
            An overridden method named DisposeCoreAsync that takes a single Boolean parameter and returns Task, as
            is used when implementing the standard DisposeAsync pattern.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.Close">
            <summary>
            A method named Close on a type that implements <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.DisposeMethodKind.CloseAsync">
            <summary>
            A method named CloseAsync that has no parameters and returns Task.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Lightup.NullableAnnotation">
            <summary>
            Represents the nullability of values that can be assigned
            to an expression used as an lvalue.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.None">
            <summary>
            The expression has not been analyzed, or the syntax is
            not an expression (such as a statement).
            </summary>
            <remarks>
            There are a few different reasons the expression could
            have not been analyzed:
                1) The symbol producing the expression comes from
                   a method that has not been annotated, such as
                   invoking a C# 7.3 or earlier method, or a
                   method in this compilation that is in a disabled
                   context.
                2) Nullable is completely disabled in this
                   compilation.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.NotAnnotated">
            <summary>
            The expression is not annotated (does not have a ?).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableAnnotation.Annotated">
            <summary>
            The expression is annotated (does have a ?).
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Lightup.NullableContext">
            <summary>
            Represents the state of the nullable analysis at a specific point in a file. Bits one and
            two correspond to whether the nullable feature is enabled. Bits three and four correspond
            to whether the context was inherited from the global context.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.Disabled">
            <summary>
            Nullable warnings and annotations are explicitly turned off at this location.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.WarningsEnabled">
            <summary>
            Nullable warnings are enabled and will be reported at this file location.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.AnnotationsEnabled">
            <summary>
            Nullable annotations are enabled and will be shown when APIs defined at
            this location are used in other contexts.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.Enabled">
            <summary>
            The nullable feature is fully enabled.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.WarningsContextInherited">
            <summary>
            The nullable warning state is inherited from the project default.
            </summary>
            <remarks>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of of the project-level
            default setting.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.AnnotationsContextInherited">
            <summary>
            The nullable annotation state is inherited from the project default.
            </summary>
            <remarks>
            The project default can change depending on the file type. Generated
            files have nullable off by default, regardless of of the project-level
            default setting.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.Lightup.NullableContext.ContextInherited">
             <summary>
             The current state of both warnings and annotations are inherited from
             the project default.
             </summary>
             <remarks>
             This flag is set by default at the start of all files.
            
             The project default can change depending on the file type. Generated
             files have nullable off by default, regardless of of the project-level
             default setting.
             </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.WarningsEnabled(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether nullable warnings are enabled for this context.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.AnnotationsEnabled(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether nullable annotations are enabled for this context.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.WarningsInherited(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether the nullable warning state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.Lightup.NullableContextExtensions.AnnotationsInherited(Analyzer.Utilities.Lightup.NullableContext)">
            <summary>
            Returns whether the nullable annotation state was inherited from the project default for this file type.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SyntaxTreeCategorizedAnalyzerConfigOptions">
            <summary>
            Analyzer configuration options for a given syntax tree from <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions"/>
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.ICategorizedAnalyzerConfigOptions">
            <summary>
            Analyzer configuration options that are parsed into general and specific configuration options.
            
            .editorconfig format:
             1) General configuration option:
                (a) "dotnet_code_quality.OptionName = OptionValue"
             2) Specific configuration option:
                (a) "dotnet_code_quality.RuleId.OptionName = OptionValue"
                (b) "dotnet_code_quality.RuleCategory.OptionName = OptionValue"
               
            .editorconfig examples to configure API surface analyzed by analyzers:
             1) General configuration option:
                (a) "dotnet_code_quality.api_surface = all"
             2) Specific configuration option:
                (a) "dotnet_code_quality.CA1040.api_surface = public, internal"
                (b) "dotnet_code_quality.Naming.api_surface = public"
             See <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> for allowed symbol visibility value combinations.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.AggregateCategorizedAnalyzerConfigOptions">
            <summary>
            Aggregate analyzer configuration options:
            1. Per syntax tree options from <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider"/>.
            2. Options from an .editorconfig file passed in as an additional file (back compat).
            
            These options are parsed into general and specific configuration options.
            
            .editorconfig format:
             1) General configuration option:
                (a) "dotnet_code_quality.OptionName = OptionValue"
             2) Specific configuration option:
                (a) "dotnet_code_quality.RuleId.OptionName = OptionValue"
                (b) "dotnet_code_quality.RuleCategory.OptionName = OptionValue"
               
            .editorconfig examples to configure API surface analyzed by analyzers:
             1) General configuration option:
                (a) "dotnet_code_quality.api_surface = all"
             2) Specific configuration option:
                (a) "dotnet_code_quality.CA1040.api_surface = public, internal"
                (b) "dotnet_code_quality.Naming.api_surface = public"
             See <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> for allowed symbol visibility value combinations.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.SymbolNamesWithValueOption`1._wildcardNamesBySymbolKind">
            <summary>
            Dictionary holding per symbol kind the wildcard entry with its suffix.
            The implementation only supports the following SymbolKind: Namespace, Type, Event, Field, Method, Property and ErrorType (as a way to hold the non-fully qualified types).
            </summary>
            <example>
            ErrorType ->
                Symbol* -> "some value"
            Namespace ->
                Analyzer.Utilities -> ""
            Type ->
                Analyzer.Utilities.SymbolNamesWithValueOption -> ""
            Event ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyEvent -> ""
            Field ->
                Analyzer.Utilities.SymbolNamesWithValueOption.myField -> ""
            Method ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyMethod() -> ""
            Property ->
                Analyzer.Utilities.SymbolNamesWithValueOption.MyProperty -> ""
            </example>
        </member>
        <member name="F:Analyzer.Utilities.SymbolNamesWithValueOption`1._wildcardMatchResult">
            <summary>
            Cache for the wildcard matching algorithm. The current implementation can be slow so we want to make sure that once a match is performed we save its result.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SymbolNamesWithValueOption`1.TryGetValue(Microsoft.CodeAnalysis.ISymbol,`0@)">
            <summary>
            Gets the value associated with the specified symbol in the option specification.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolNamesWithValueOption`1.NameParts">
            <summary>
            Represents the two parts of a symbol name option when the symbol name is tighted to some specific value.
            This allows to link a value to a symbol while following the symbol's documentation ID format.
            </summary>
            <example>
            On the rule CA1710, we allow user specific suffix to be registered for symbol names using the following format:
            MyClass->Suffix or T:MyNamespace.MyClass->Suffix or N:MyNamespace->Suffix.
            </example>
        </member>
        <member name="T:Analyzer.Utilities.SymbolModifiers">
            <summary>
            Describes a group of modifiers for symbol declaration.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.Unit">
            <summary>
            Represents a type with a single value. This type is often used to denote the successful completion of a void-returning method (C#) or a Sub procedure (Visual Basic).
            </summary>
            <remarks>
            This class is a duplicate from "https://github.com/dotnet/reactive/blob/master/Rx.NET/Source/src/System.Reactive/Unit.cs
            </remarks>
        </member>
        <member name="M:Analyzer.Utilities.Unit.Equals(Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the specified <see cref="T:Analyzer.Utilities.Unit"/> value is equal to the current <see cref="T:Analyzer.Utilities.Unit"/>. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.
            </summary>
            <param name="other">An object to compare to the current <see cref="T:Analyzer.Utilities.Unit"/> value.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current <see cref="T:Analyzer.Utilities.Unit"/>.
            </summary>
            <param name="obj">The System.Object to compare with the current <see cref="T:Analyzer.Utilities.Unit"/>.</param>
            <returns><c>true</c> if the specified System.Object is a <see cref="T:Analyzer.Utilities.Unit"/> value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
            <returns>A hash code for the current <see cref="T:Analyzer.Utilities.Unit"/> value.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.ToString">
            <summary>
            Returns a string representation of the current <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
            <returns>String representation of the current <see cref="T:Analyzer.Utilities.Unit"/> value.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.op_Equality(Analyzer.Utilities.Unit,Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the two specified <see cref="T:Analyzer.Utilities.Unit"/> values are equal. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.
            </summary>
            <param name="first">The first <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <param name="second">The second <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>true</c>.</returns>
        </member>
        <member name="M:Analyzer.Utilities.Unit.op_Inequality(Analyzer.Utilities.Unit,Analyzer.Utilities.Unit)">
            <summary>
            Determines whether the two specified <see cref="T:Analyzer.Utilities.Unit"/> values are not equal. Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>false</c>.
            </summary>
            <param name="first">The first <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <param name="second">The second <see cref="T:Analyzer.Utilities.Unit"/> value to compare.</param>
            <returns>Because <see cref="T:Analyzer.Utilities.Unit"/> has a single value, this always returns <c>false</c>.</returns>
        </member>
        <member name="P:Analyzer.Utilities.Unit.Default">
            <summary>
            Gets the single <see cref="T:Analyzer.Utilities.Unit"/> value.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.EditorConfigOptionNames">
            <summary>
            Option names to configure analyzer execution through an .editorconfig file.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ApiSurface">
            <summary>
            Option to configure analyzed API surface.
            Allowed option values: One or more fields of flags enum <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.RequiredModifiers">
            <summary>
            Option to configure required modifiers for analyzed APIs.
            Allowed option values: One or more fields of flags enum <see cref="T:Analyzer.Utilities.SymbolModifiers"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeAsyncVoidMethods">
            <summary>
            Boolean option to exclude analysis of async void methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.OutputKind">
            <summary>
            Option to configure analyzed output kinds, i.e. <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/> of the compilation.
            Allowed option values: One or more fields of <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.OutputKind"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeSingleLetterTypeParameters">
            <summary>
            Boolean option to configure if single letter type parameter names are not flagged for CA1715 (https://docs.microsoft.com/visualstudio/code-quality/ca1715).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.SufficientIterationCountForWeakKDFAlgorithm">
            <summary>
            Integral option to configure sufficient IterationCount when using weak KDF algorithm.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeExtensionMethodThisParameter">
            <summary>
            Boolean option to exclude analysis of 'this' parameter for extension methods.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.NullCheckValidationMethods">
            <summary>
            String option to configure names of null check validation methods (separated by '|') that validate arguments passed to the method are non-null for CA1062 (https://docs.microsoft.com/visualstudio/code-quality/ca1062).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalStringFormattingMethods">
            <summary>
            String option to configure names of additional string formatting methods (separated by '|') for CA2241 (https://docs.microsoft.com/visualstudio/code-quality/ca2241).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.TryDetermineAdditionalStringFormattingMethodsAutomatically">
            <summary>
            Boolean option to enable heuristically detecting of additional string formatting methods for CA2241 (https://docs.microsoft.com/visualstudio/code-quality/ca2241).
            A method is considered a string formatting method if it has a '<see cref="T:System.String"/> <c>format</c>' parameter followed by a <see langword="params"/> <see cref="T:System.Object"/>[]' parameter.
            The default value of this is <c>false</c>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludedSymbolNames">
            <summary>
            String option to configure names of symbols (separated by '|') that are excluded for analysis.
            Configurable rules: CA1303 (https://docs.microsoft.com/visualstudio/code-quality/ca1303).
            Allowed method name formats:
              1. Symbol name only (includes all symbols with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format.
                 Note that each symbol name requires a symbol kind prefix, such as "M:" prefix for methods, "T:" prefix for types, "N:" prefix for namespaces, etc.
              3. ".ctor" for constructors and ".cctor" for static constructors
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludedTypeNamesWithDerivedTypes">
            <summary>
            String option to configure names of types (separated by '|'), so that the type and all its derived types are excluded for analysis.
            Configurable rules: CA1303 (https://docs.microsoft.com/visualstudio/code-quality/ca1303).
            Allowed method name formats:
              1. Type name only (includes all types with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format
                 with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.DisallowedSymbolNames">
            <summary>
            String option to configure names of symbols (separated by '|') that are disallowed in analysis.
            Configurable rules: CA1031 (https://docs.microsoft.com/visualstudio/code-quality/ca1031).
            Allowed method name formats:
              1. Symbol name only (includes all symbols with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format.
                 Note that each symbol name requires a symbol kind prefix, such as "M:" prefix for methods, "T:" prefix for types, "N:" prefix for namespaces, etc.
              3. ".ctor" for constructors and ".cctor" for static constructors
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.UnsafeDllImportSearchPathBits">
            <summary>
            Enumeration option to configure unsafe DllImportSearchPath bits when using DefaultDllImportSearchPaths attribute.
            Do not use the OR operator to represent the bitwise combination of its member values, use the integeral value directly.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeAspnetCoreMvcControllerBase">
            <summary>
            Boolean option to configure whether to exclude aspnet core mvc ControllerBase when considering CSRF.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.EnumValuesPrefixTrigger">
            <summary>
            String option to configure how many enum values should be prefixed by the enum type name to trigger the rule.
            Configurable rules: CA1712 (https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1712)
            Allowed method name formats:
              1. Any of the enum values starts with the enum type name
              2. All of the enum values starts with the enum type name
              3. Default FxCop heuristic (75% of enum values)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalRequiredSuffixes">
            <summary>
            String option to configure names of types (separated by '|'), with their suffixes (separated by '->').
            Configurable rules: CA1710 (https://docs.microsoft.com/visualstudio/code-quality/ca1710).
            Allowed type name formats:
              1. Type name only (includes all types with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format
                 with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.ExcludeIndirectBaseTypes">
            <summary>
            Boolean option to prevent analyzing indirect base types (walking more than one level up) when suggesting suffixes.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalRequiredGenericInterfaces">
            <summary>
            String option to configure names of interfaces (separated by '|'), with their required generic interfaces (separated by '->').
            Configurable rules: CA1010 (https://docs.microsoft.com/visualstudio/code-quality/ca1010)
            Allowed interface formats:
              1. Interface name only(includes all interfaces with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format with an optional "T:" prefix.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalInheritanceExcludedSymbolNames">
            <summary>
            Names of types or namespaces (separated by '|'), such that the type or type's namespace doesn't count in the inheritance hierarchy tree.
            Configurable rules: CA1501 (https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1501)
            Allowed name formats:
              1. Type or namespace name (includes all types with the name, regardless of the containing type or namespace and all types whose namespace contains the name)
              2. Type or namespace name ending with a wildcard symbol (includes all types whose name starts with the given name, regardless of the containing type or namespace
                 and all types whose namespace contains the name)
              3. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format with an optional "T:" prefix for types or "N:" prefix for namespaces. (includes all types with the exact type match or the exact containing namespace match)
              4. Fully qualified type or namespace name with an optional "T:" prefix for type or "N:" prefix for namespace and ending with the wildcard symbol (includes all types whose fully qualified name starts with the given suffix)
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AnalyzedSymbolKinds">
            <summary>
            Option to configure analyzed symbol kinds, i.e. <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>.
            Allowed option values: One or more fields of <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/> as a comma separated list.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.UseNamingHeuristic">
            <summary>
            Boolean option to configure if the naming heuristic should be used for CA1303 (https://docs.microsoft.com/en-us/visualstudio/code-quality/ca1303).
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigOptionNames.AdditionalUseResultsMethods">
            <summary>
            String option to configure names of additional methods (separated by '|') for CA1806 (https://docs.microsoft.com/visualstudio/code-quality/ca1806).
            Allowed method name formats:
              1. Method name only (includes all methods with the name, regardless of the containing type or namespace)
              2. Fully qualified names in the symbol's documentation ID format: https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format
                 with an optional "M:" prefix.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.SymbolVisibilityGroup">
            <summary>
            Describes a group of effective <see cref="T:Analyzer.Utilities.Extensions.SymbolVisibility"/> for symbols.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.CompilationCategorizedAnalyzerConfigOptions">
            <summary>
            Analyzer configuration options from an .editorconfig file that are parsed into general
            and specific configuration options.
            
            .editorconfig format:
             1) General configuration option:
                (a) "dotnet_code_quality.OptionName = OptionValue"
             2) Specific configuration option:
                (a) "dotnet_code_quality.RuleId.OptionName = OptionValue"
                (b) "dotnet_code_quality.RuleCategory.OptionName = OptionValue"
               
            .editorconfig examples to configure API surface analyzed by analyzers:
             1) General configuration option:
                (a) "dotnet_code_quality.api_surface = all"
             2) Specific configuration option:
                (a) "dotnet_code_quality.CA1040.api_surface = public, internal"
                (b) "dotnet_code_quality.Naming.api_surface = public"
             See <see cref="T:Analyzer.Utilities.SymbolVisibilityGroup"/> for allowed symbol visibility value combinations.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.EditorConfigParser">
            <summary>
            Parses a given .editorconfig source text into <see cref="T:Analyzer.Utilities.CompilationCategorizedAnalyzerConfigOptions"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigParser.s_reservedKeys">
            <summary>
            A set of keys that are reserved for special interpretation for the editorconfig specification.
            All values corresponding to reserved keys in a (key,value) property pair are always lowercased
            during parsing.
            </summary>
            <remarks>
            This list was retrieved from https://github.com/editorconfig/editorconfig/wiki/EditorConfig-Properties
            at 2018-04-21 19:37:05Z. New keys may be added to this list in newer versions, but old ones will
            not be removed.
            </remarks>
        </member>
        <member name="F:Analyzer.Utilities.EditorConfigParser.s_reservedValues">
            <summary>
            A set of values that are reserved for special use for the editorconfig specification
            and will always be lower-cased by the parser.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Analyzer.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="T:Analyzer.Utilities.UnusedValue">
            <summary>
            A placeholder value type for <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> used as a set.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.WellKnownTypeProvider">
            <summary>
            Provides and caches well known types in a compilation.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WellKnownTypeProvider._fullNameToTypeMap">
            <summary>
            Mapping of full name to <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.TryGetOrCreateTypeByMetadataName(System.String,Microsoft.CodeAnalysis.INamedTypeSymbol@)">
            <summary>
            Attempts to get the type by the full type name.
            </summary>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <param name="namedTypeSymbol">Named type symbol, if any.</param>
            <returns>True if found in the compilation, false otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.GetOrCreateTypeByMetadataName(System.String)">
            <summary>
            Gets a type by its full type name.
            </summary>
            <param name="fullTypeName">Namespace + type name, e.g. "System.Exception".</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> if found, null otherwise.</returns>
        </member>
        <member name="M:Analyzer.Utilities.WellKnownTypeProvider.IsTaskOfType(Microsoft.CodeAnalysis.ITypeSymbol,System.Func{Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean})">
            <summary>
            Determines if <paramref name="typeSymbol"/> is a <see cref="T:System.Threading.Tasks.Task`1"/> with its type
            argument satisfying <paramref name="typeArgumentPredicate"/>.
            </summary>
            <param name="typeSymbol">Type potentially representing a <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <param name="typeArgumentPredicate">Predicate to check the <paramref name="typeSymbol"/>'s type argument.</param>
            <returns>True if <paramref name="typeSymbol"/> is a <see cref="T:System.Threading.Tasks.Task`1"/> with its
            type argument satisfying <paramref name="typeArgumentPredicate"/>, false otherwise.</returns>
        </member>
        <member name="T:Analyzer.Utilities.BoundedCache`2">
            <summary>
            Provides bounded cache for analyzers.
            Acts as a good alternative to <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/>
            when the cached value has a cyclic reference to the key preventing early garbage collection of entries.
            </summary>
        </member>
        <member name="T:Analyzer.Utilities.WordParser">
            <summary>
                Provides <see langword="static"/> methods for parsing words from text.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.#ctor(System.String,Analyzer.Utilities.WordParserOptions)">
            <summary>
                Initializes a new instance of the <see cref="T:Analyzer.Utilities.WordParser"/> class with the specified text and options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.#ctor(System.String,Analyzer.Utilities.WordParserOptions,System.Char)">
            <summary>
                Initializes a new instance of the <see cref="T:Analyzer.Utilities.WordParser"/> class with the specified text, options and prefix.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)">
            <summary>
                Returns the words contained in the specified text, delimiting based on the specified options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <returns>
                A <see cref="T:System.Collections.ObjectModel.Collection`1"/> of strings containing the words contained in <paramref name="text"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions,System.Char)">
            <summary>
                Returns the words contained in the specified text, delimiting based on the specified options.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to parse.
            </param>
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <returns>
                A <see cref="T:System.Collections.ObjectModel.Collection`1"/> of strings containing the words contained in <paramref name="text"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.ContainsWord(System.String,Analyzer.Utilities.WordParserOptions,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
                Returns a value indicating whether at least one of the specified words occurs, using a case-insensitive ordinal comparison, within the specified text.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to check.
            </param>    
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="words">
                A <see cref="T:System.String"/> array containing the words to seek.
            </param>
            <returns>
                <see langword="true"/> if at least one of the elements within <paramref name="words"/> occurs within <paramref name="text"/>, otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
                <para>
                 -or-
                </para>
                <paramref name="words"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.ContainsWord(System.String,Analyzer.Utilities.WordParserOptions,System.Char,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
                Returns a value indicating whether at least one of the specified words occurs, using a case-insensitive ordinal comparison, within the specified text.
            </summary>
            <param name="text">
                A <see cref="T:System.String"/> containing the text to check.
            </param>    
            <param name="options">
                One or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> specifying parsing and delimiting options.
            </param>
            <param name="prefix">
                A <see cref="T:System.Char"/> representing an optional prefix of <paramref name="text"/>, that if present,
                will be returned as a separate token.
            </param>
            <param name="words">
                A <see cref="T:System.String"/> array containing the words to seek.
            </param>
            <returns>
                <see langword="true"/> if at least one of the elements within <paramref name="words"/> occurs within <paramref name="text"/>, otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="text"/> is <see langword="null"/>.
                <para>
                 -or-
                </para>
                <paramref name="words"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="options"/> is not one or more of the <see cref="T:Analyzer.Utilities.WordParserOptions"/> values.
            </exception>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.NextWord">
            <summary>
                Returns the next word in the text.
            </summary>
            <returns>
                A <see cref="T:System.String"/> containing the next word or <see langword="null"/> if there are no more words.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.WordParser.PeekWord">
            <summary>
                Returns the next word in the text without consuming it.
            </summary>
            <returns>
                A <see cref="T:System.String"/> containing the next word or <see langword="null"/> if there are no more words.
            </returns>
        </member>
        <member name="T:Analyzer.Utilities.WordParserOptions">
            <summary>
              Defines the word parsing and delimiting options for use with <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/>.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.None">
            <summary>
              Indicates the default options for word parsing.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.IgnoreMnemonicsIndicators">
            <summary>
              Indicates that <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/> should ignore the mnemonic indicator characters (&amp;) embedded within words.
            </summary>
        </member>
        <member name="F:Analyzer.Utilities.WordParserOptions.SplitCompoundWords">
            <summary>
              Indicates that <see cref="M:Analyzer.Utilities.WordParser.Parse(System.String,Analyzer.Utilities.WordParserOptions)"/> should split compound words.
            </summary>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorEqualityDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator equality overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.TypeExpressionForStaticMemberAccess(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a reference to a named type suitable for use in accessing a static member of the type.
            </summary>
            <param name="generator">The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the type reference.</param>
            <param name="typeSymbol">The named type to reference.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the type reference expression.</returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorInequalityDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator inequality overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorLessThanDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator less than overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorLessThanOrEqualDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator less than or equal overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorGreaterThanDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator greater than overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultOperatorGreaterThanOrEqualDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an operator greater than or equal overload.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="containingType">
            A symbol specifying the type of the operands of the comparison operator.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultEqualsOverrideDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Creates a default declaration for an override of <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="compilation">The compilation</param>
            <param name="containingType">
            A symbol specifying the type in which the declaration is to be created.
            </param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultGetHashCodeOverrideDeclaration(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Creates a default declaration for an override of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the declaration.
            </param>
            <param name="compilation">The compilation</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> representing the declaration.
            </returns>
        </member>
        <member name="M:Analyzer.Utilities.SyntaxGeneratorExtensions.DefaultMethodBody(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Creates a default set of statements to place within a generated method body.
            </summary>
            <param name="generator">
            The <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> used to create the statements.
            </param>
            <param name="compilation">The compilation</param>
            <returns>
            An sequence containing a single statement that throws <see cref="T:System.NotImplementedException"/>.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData">
            <summary>
            Code analysis metrics data.
            See https://docs.microsoft.com/visualstudio/code-quality/code-metrics-values for more details
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Symbol">
            <summary>
            Symbol corresponding to the metric data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.MaintainabilityIndex">
            <summary>
            Indicates an index value between 0 and 100 that represents the relative ease of maintaining the code.
            A high value means better maintainability.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.CoupledNamedTypes">
            <summary>
            Indicates the coupling to unique named types through parameters, local variables, return types, method calls,
            generic or template instantiations, base classes, interface implementations, fields defined on external types, and attribute decoration.
            Good software design dictates that types and methods should have high cohesion and low coupling.
            High coupling indicates a design that is difficult to reuse and maintain because of its many interdependencies on other types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.SourceLines">
            <summary>
            Indicates the exact number of lines in source code file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ExecutableLines">
            <summary>
            Indicates the approximate number of executable statements/lines in code.
            The count is based on the executable <see cref="T:Microsoft.CodeAnalysis.IOperation"/>s in code and is therefore not the exact number of lines in the source code file.
            A high count might indicate that a type or method is trying to do too much work and should be split up.
            It might also indicate that the type or method might be hard to maintain.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.CyclomaticComplexity">
            <summary>
            Measures the structural complexity of the code.
            It is created by calculating the number of different code paths in the flow of the program.
            A program that has complex control flow requires more tests to achieve good code coverage and is less maintainable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.DepthOfInheritance">
            <summary>
            Indicates the number of different classes that inherit from one another, all the way back to the base class.
            Depth of Inheritance is similar to class coupling in that a change in a base class can affect any of its inherited classes.
            The higher this number, the deeper the inheritance and the higher the potential for base class modifications to result in a breaking change.
            For Depth of Inheritance, a low value is good and a high value is bad.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Children">
            <summary>
            Array of code metrics data for symbolic children of <see cref="P:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.Symbol"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ToString">
            <summary>
            Computes string representation of metrics data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="symbol"/> from the given <paramref name="compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData.ComputeAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext)">
            <summary>
            Computes <see cref="T:Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData"/> for the given <paramref name="symbol"/> from the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics">
            <summary>
            Calculates computational complexity metrics based on the number 
            of operators and operands found in the code.
            </summary>
            <remarks>This metric is based off of the Halstead metric.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.DistinctOperators">
            <summary>The number of unique operators found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.DistinctOperands">
            <summary>The number of unique operands found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.TotalOperators">
            <summary>The total number of operator usages found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.TotalOperands">
            <summary>The total number of operand usages found.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.ExecutableLines">
            <summary>
            Count of executable lines of code, i.e. basically IOperations parented by IBlockOperation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics.EffectiveLinesOfCode">
            <summary>
            Count of effective lines of code for computation of maintainability index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter.GenerateEditorconfig(System.String,System.String)">
            <summary>
            Converts a ruleset file at the given <paramref name="rulesetFilePath"/>, including all its ruleset includes,
            into an .editorconfig file at the given <paramref name="editorconfigFilePath"/>
            </summary>
            <exception cref="T:System.IO.IOException">Exception while performing any I/O on given file paths.</exception>
            <exception cref="T:Microsoft.CodeAnalysis.InvalidRuleSetException">Exception for invalid ruleset files.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter.GetEditorconfig(System.String)">
            <summary>
            Gets an .editorconfig representation for a ruleset file at the given <paramref name="rulesetFilePath"/>,
            including all its ruleset includes.
            </summary>
            <returns>Text for equivalent .editorconfig</returns>
            <exception cref="T:System.IO.IOException">Exception while performing any I/O on given file paths.</exception>
            <exception cref="T:Microsoft.CodeAnalysis.InvalidRuleSetException">Exception for invalid ruleset file.</exception>
        </member>
    </members>
</doc>
